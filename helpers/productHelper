const Product = require('../models/product');
const Category= require('../models/category')
const User = require('../models/usermodel');
const fs = require('fs').promises;
const path = require('path');
const bcrypt = require('bcryptjs');

module.exports = {

  getAllProducts: async () => {
    try {
      const result = await Product.find({}).populate('category').lean();
      return result;
    } catch (error) {
      throw new Error('Error fetching all products');
    }
  },
  getAllCategories : async () => {
    try {
      const categories = await Category.find({}).lean();
      return categories;
    } catch (error) {
      throw new Error('Error fetching all categories');
    }
  },
  getProductsByCategoryName: async (categoryName) => {
    try {
      const selectedCategory = await Category.findOne({ name: categoryName });

      if (!selectedCategory) {
        return [];
      }

      const products = await Product.find({ category: selectedCategory._id }).populate('category').lean();
      return products;
    } catch (error) {
      throw new Error('Error fetching products by category');
    }
  },


  addProduct: async (productData) => {
    try {
      const product = new Product(productData);
      await product.save();
    } catch (error) {
      throw new Error('Error adding product');
    }
  },
  
  getProductById: async (productId) => {
    try {
      const product = await Product.findById(productId);
      return product;
    } catch (error) {
      console.error('Error retrieving product by ID:', error);
      throw new Error('Error retrieving product by ID');
    }
  },

  
  updateProductById: async (productId, updatedData) => {
    try {
        // Use findByIdAndUpdate to find the product by ID and update its data
        const updatedProduct = await Product.findByIdAndUpdate(productId, updatedData, { new: true });

        if (updatedProduct) {
            console.log('Product updated successfully:', updatedProduct);
            return updatedProduct;
        } else {
            console.log('Product not found');
            return null;
        }
    } catch (error) {
        console.error('Error updating product:', error.message);
        throw new Error('Error updating product');
    }
},




  deleteProductById: async (productId) => {
    try {
      const product = await Product.findById(productId);

      if (!product) {
        throw new Error('Product not found');
      }

      const imagePath = './public/' + product.image; // Manually construct the path
      console.log('Deleting file at path:', imagePath);
      try {
        await fs.unlink(imagePath);
        console.log('File deleted successfully:', imagePath);
      } catch (unlinkError) {
        console.error('Error deleting file:', unlinkError.message);
      }

      await Product.deleteOne({ _id: productId });
    } catch (error) {
      console.error('Error deleting product:', error.message);
      throw new Error('Error deleting product');
    }
  },
  
  registerAdmin: async (adminData) => {
    const { name, username, email, password, phone } = adminData;

    // Hash the password
    const hashedPassword = await bcrypt.hash(password, 10);

    // Create a new User instance with the 'admin' role
    const newAdmin = new User({
      name,
      username,
      email,
      password: hashedPassword,
      phone,
      role: 'admin',
    });

    // Save the new admin to the database
    await newAdmin.save();
  },



  performSearch: async (searchQuery) => {

    const regex = new RegExp(searchQuery, 'i');

    try {
        // Query the database for products matching the search criteria
        const searchResults = await Product.find({ name: regex });
        return searchResults;
    } catch (error) {
        console.error(error);
        throw new Error('Error performing search');
    }
},
};



  


